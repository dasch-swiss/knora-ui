[
  {
    "tags": [
      {
        "type": "param",
        "string": "{string} [iri] Resource iri",
        "name": "[iri]",
        "description": "<p>Resource iri</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 19,
    "codeStart": 22,
    "code": "@Input() iri?: string;\n\n@ViewChild('kuiStillImage', { static: false }) kuiStillImage: StillImageComponent;\n\nsequence: ResourcesSequence;\n\nontologyInfo: OntologyInformation;\nguiOrder: GuiOrder[];\nloading: boolean;\nerror: KuiMessageData;\nKnoraConstants = KnoraConstants;\n\n// does the resource has a file representation (media file)?\nfileRepresentation: boolean;\n\n// current resource in case of compound object\ncurrentResource: ReadResource;\n\nconstructor (protected _route: ActivatedRoute,\n    protected _router: Router,\n    protected _resourceService: ResourceService,\n    protected _incomingService: IncomingService\n) {\n\n}\n\nngOnInit() {\n    // this.getResource(this.iri);\n}\n\nngOnChanges() {\n    this.getResource(this.iri);\n\n    // console.log(this.kuiStillImage.k;\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string} id Resource iri",
        "name": "id",
        "description": "<p>Resource iri</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "<p>Get a read resource sequence with ontology information and incoming resources.</p>",
      "summary": "<p>Get a read resource sequence with ontology information and incoming resources.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 58,
    "codeStart": 63,
    "code": "getResource(id: string) {\n    this.loading = true;\n    this.error = undefined;\n    this._resourceService.getResource(decodeURIComponent(id)).subscribe(\n        (result: ResourcesSequence) => {\n\n            // console.log('getResource result', result);\n\n            // result with resources only and WITHOUT incoming stuff\n            this.sequence = result;\n\n            // this.ontologyInfo = result.ontologyInformation;\n\n            // const resType = this.sequence.resources[0].type;\n\n            this.guiOrder = result.ontologyInformation.getResourceClasses()[this.sequence.resources[0].type].guiOrder;\n\n            // collect all filerepresentations to display including annotations\n            // --> for the first resource only...\n            // this.sequence.resources[0].fileRepresentationsToDisplay = this.collectFileRepresentationsAndFileAnnotations(this.sequence.resources[0]);\n\n            // collect images and regions\n            // --> for the first resource only...\n            // this.collectImagesAndRegionsForResource(this.sequence.resources[0]);\n\n            // get incoming resources\n            //                this.requestIncomingResources();\n\n\n            // this.fileRepresentation = this.sequence.resources[0].properties.indexOf(KnoraConstants.hasStillImageFileValue) > -1;\n\n            // console.log('fileRepresentation', this.sequence.resources[0].stillImageRepresentationsToDisplay[0].stillImageFileValue);\n\n            // wait until the resource is ready\n            setTimeout(() => {\n                // console.log(this.sequence);\n                this.currentResource = this.sequence.resources[0].incomingFileRepresentations[0];\n                // console.log('currentResource', this.sequence.resources[0].incomingFileRepresentations[0]);\n                this.loading = false;\n            }, 1000);\n        },\n        (error: ApiServiceError) => {\n            // console.error(error);\n\n            const statusText: string = (error.status === 404 ? 'One or more requested resources were not found (maybe you do not have permission to see them, or they are marked as deleted).' : undefined);\n\n            this.error = {\n                status: error.status,\n                statusMsg: error.statusText,\n                statusText: statusText,\n                url: error.url\n            };\n\n            this.loading = false;\n        }\n    );\n}",
    "ctx": {
      "type": "method",
      "name": "getResource",
      "string": "getResource()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "resource",
        "name": "resource",
        "description": "",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "html": "<p>resource</p>"
      }
    ],
    "description": {
      "full": "<p>Collect all file representations (stillImage, movingImage, audio etc.) and annotations (region, sequence etc.)</p>",
      "summary": "<p>Collect all file representations (stillImage, movingImage, audio etc.) and annotations (region, sequence etc.)</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 122,
    "codeStart": 127
  },
  {
    "tags": [],
    "description": {
      "full": "<p>collectFileRepresentationsAndFileAnnotations(resource: Resource): FileRepresentation[] {<br />\nconst fileRepresentations: FileRepresentation[] = [];</p>\n<pre><code>    if (resource.properties[KnoraConstants.hasStillImageFileValue] !== undefined) {\n        const fileValues: ReadStillImageFileValue[] = resource.properties[KnoraConstants.hasStillImageFileValue] as ReadStillImageFileValue[];\n    }\n\n    return fileRepresentations;\n}\n\n/*\n\n    collectImagesAndRegionsForResource(resource: Resource): void {\n\n        const imgRepresentations: StillImageRepresentation[] = [];\n\n        if (resource.properties[KnoraConstants.hasStillImageFileValue] !== undefined) {\n            // TODO: check if resources is a StillImageRepresentation using the ontology responder (support for subclass relations required)\n            // resource has StillImageFileValues that are directly attached to it (properties)\n\n            const fileValues: ReadStillImageFileValue[] = resource.properties[KnoraConstants.hasStillImageFileValue] as ReadStillImageFileValue[];\n            const imagesToDisplay: ReadStillImageFileValue[] = fileValues.filter((image) =&gt; {\n                return !image.isPreview;\n            });\n\n\n            for (const img of imagesToDisplay) {\n\n                const regions: ImageRegion[] = [];\n                for (const incomingRegion of resource.incomingAnnotations) {\n\n                    const region = new ImageRegion(incomingRegion);\n\n                    regions.push(region);\n\n                }\n\n                const stillImage = new StillImageRepresentation(img, regions);\n                imgRepresentations.push(stillImage);\n\n            }\n\n\n        } else if (resource.incomingStillImageRepresentations.length &gt; 0) {\n            // there are StillImageRepresentations pointing to this resource (incoming)\n\n            const readStillImageFileValues: ReadStillImageFileValue[] = resource.incomingStillImageRepresentations.map(\n                (stillImageRes: ReadResource) =&gt; {\n                    const fileValues = stillImageRes.properties[KnoraConstants.hasStillImageFileValue] as ReadStillImageFileValue[];\n                    // TODO: check if resources is a StillImageRepresentation using the ontology responder (support for subclass relations required)\n                    const imagesToDisplay = fileValues.filter((image) =&gt; {\n                        return !image.isPreview;\n\n                    });\n\n                    return imagesToDisplay;\n                }\n            ).reduce(function (prev, curr) {\n                // transform ReadStillImageFileValue[][] to ReadStillImageFileValue[]\n                return prev.concat(curr);\n            });\n\n            for (const img of readStillImageFileValues) {\n\n                const regions: ImageRegion[] = [];\n                for (const incomingRegion of resource.incomingRegions) {\n\n                    const region = new ImageRegion(incomingRegion);\n                    regions.push(region);\n\n                }\n\n                const stillImage = new StillImageRepresentation(img, regions);\n                imgRepresentations.push(stillImage);\n            }\n\n        }\n\n        resource.stillImageRepresentationsToDisplay = imgRepresentations;\n\n    }</code></pre>",
      "summary": "<p>collectFileRepresentationsAndFileAnnotations(resource: Resource): FileRepresentation[] {<br />\nconst fileRepresentations: FileRepresentation[] = [];</p>",
      "body": "<pre><code>    if (resource.properties[KnoraConstants.hasStillImageFileValue] !== undefined) {\n        const fileValues: ReadStillImageFileValue[] = resource.properties[KnoraConstants.hasStillImageFileValue] as ReadStillImageFileValue[];\n    }\n\n    return fileRepresentations;\n}\n\n/*\n\n    collectImagesAndRegionsForResource(resource: Resource): void {\n\n        const imgRepresentations: StillImageRepresentation[] = [];\n\n        if (resource.properties[KnoraConstants.hasStillImageFileValue] !== undefined) {\n            // TODO: check if resources is a StillImageRepresentation using the ontology responder (support for subclass relations required)\n            // resource has StillImageFileValues that are directly attached to it (properties)\n\n            const fileValues: ReadStillImageFileValue[] = resource.properties[KnoraConstants.hasStillImageFileValue] as ReadStillImageFileValue[];\n            const imagesToDisplay: ReadStillImageFileValue[] = fileValues.filter((image) =&gt; {\n                return !image.isPreview;\n            });\n\n\n            for (const img of imagesToDisplay) {\n\n                const regions: ImageRegion[] = [];\n                for (const incomingRegion of resource.incomingAnnotations) {\n\n                    const region = new ImageRegion(incomingRegion);\n\n                    regions.push(region);\n\n                }\n\n                const stillImage = new StillImageRepresentation(img, regions);\n                imgRepresentations.push(stillImage);\n\n            }\n\n\n        } else if (resource.incomingStillImageRepresentations.length &gt; 0) {\n            // there are StillImageRepresentations pointing to this resource (incoming)\n\n            const readStillImageFileValues: ReadStillImageFileValue[] = resource.incomingStillImageRepresentations.map(\n                (stillImageRes: ReadResource) =&gt; {\n                    const fileValues = stillImageRes.properties[KnoraConstants.hasStillImageFileValue] as ReadStillImageFileValue[];\n                    // TODO: check if resources is a StillImageRepresentation using the ontology responder (support for subclass relations required)\n                    const imagesToDisplay = fileValues.filter((image) =&gt; {\n                        return !image.isPreview;\n\n                    });\n\n                    return imagesToDisplay;\n                }\n            ).reduce(function (prev, curr) {\n                // transform ReadStillImageFileValue[][] to ReadStillImageFileValue[]\n                return prev.concat(curr);\n            });\n\n            for (const img of readStillImageFileValues) {\n\n                const regions: ImageRegion[] = [];\n                for (const incomingRegion of resource.incomingRegions) {\n\n                    const region = new ImageRegion(incomingRegion);\n                    regions.push(region);\n\n                }\n\n                const stillImage = new StillImageRepresentation(img, regions);\n                imgRepresentations.push(stillImage);\n            }\n\n        }\n\n        resource.stillImageRepresentationsToDisplay = imgRepresentations;\n\n    }</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 127,
    "codeStart": 210
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Get incoming resources: incoming links, incoming regions, incoming still image representations.</p>",
      "summary": "<p>Get incoming resources: incoming links, incoming regions, incoming still image representations.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 211,
    "codeStart": 214,
    "code": "requestIncomingResources(): void {\n\n    // make sure that this.sequence has been initialized correctly\n    if (this.sequence === undefined) {\n        return;\n    }\n\n    // request incoming regions\n    if (this.sequence.resources[0].properties[KnoraConstants.hasStillImageFileValue]) {\n        // TODO: check if resources is a StillImageRepresentation using the ontology responder (support for subclass relations required)\n        // the resource is a StillImageRepresentation, check if there are regions pointing to it\n\n        // this.getIncomingRegions(0);\n\n    } else {\n        // this resource is not a StillImageRepresentation\n        // check if there are StillImageRepresentations pointing to this resource\n\n        // this gets the first page of incoming StillImageRepresentations\n        // more pages may be requested by [[this.viewer]].\n        // TODO: for now, we begin with offset 0. This may have to be changed later (beginning somewhere in a collection)\n        // this.getIncomingStillImageRepresentations(0);\n    }\n\n    // check for incoming links for the current resource\n    this.getIncomingLinks(0);\n\n\n}",
    "ctx": {
      "type": "method",
      "name": "requestIncomingResources",
      "string": "requestIncomingResources()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "offset",
        "name": "offset",
        "description": "",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "html": "<p>offset</p>"
      },
      {
        "type": "param",
        "string": "callback\n\n    getIncomingRegions(offset: number, callback?: (numberOfResources: number) => void): void {\n        this._incomingService.getIncomingRegions(this.sequence.resources[0].id, offset).subscribe(\n            (regions: ReadResourcesSequence) => {\n                // update ontology information\n                this.ontologyInfo.updateOntologyInformation(regions.ontologyInformation);\n\n                // Append elements of regions.resources to resource.incoming\n                Array.prototype.push.apply(this.sequence.resources[0].incomingRegions, regions.resources);\n\n                // prepare regions to be displayed\n                this.collectImagesAndRegionsForResource(this.sequence.resources[0]);\n\n                // TODO: implement osdViewer\n                /* if (this.osdViewer) {\n                  this.osdViewer.updateRegions();\n                } *\n\n                // if callback is given, execute function with the amount of new images as the parameter\n                if (callback !== undefined) {\n                    callback(regions.resources.length);\n                }\n            },\n            (error: any) => {\n                console.error(error);\n                this.loading = false;\n            }\n        );\n    }",
        "name": "callback",
        "description": "<pre><code>getIncomingRegions(offset: number, callback?: (numberOfResources: number) =&gt; void): void {\n    this._incomingService.getIncomingRegions(this.sequence.resources[0].id, offset).subscribe(\n        (regions: ReadResourcesSequence) =&gt; {\n            // update ontology information\n            this.ontologyInfo.updateOntologyInformation(regions.ontologyInformation);\n\n            // Append elements of regions.resources to resource.incoming\n            Array.prototype.push.apply(this.sequence.resources[0].incomingRegions, regions.resources);\n\n            // prepare regions to be displayed\n            this.collectImagesAndRegionsForResource(this.sequence.resources[0]);\n\n            // TODO: implement osdViewer\n            /* if (this.osdViewer) {\n              this.osdViewer.updateRegions();\n            } *\n\n            // if callback is given, execute function with the amount of new images as the parameter\n            if (callback !== undefined) {\n                callback(regions.resources.length);\n            }\n        },\n        (error: any) =&gt; {\n            console.error(error);\n            this.loading = false;\n        }\n    );\n}</code></pre>",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false
      }
    ],
    "description": {
      "full": "<p>Get incoming regions for the resource.</p>",
      "summary": "<p>Get incoming regions for the resource.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 244,
    "codeStart": 280
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "offset",
        "name": "offset",
        "description": "",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "html": "<p>offset</p>"
      },
      {
        "type": "param",
        "string": "callback",
        "name": "callback",
        "description": "",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "html": "<p>callback</p>"
      }
    ],
    "description": {
      "full": "<p>Get incoming links for a resource.</p>",
      "summary": "<p>Get incoming links for a resource.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 280,
    "codeStart": 286,
    "code": "getIncomingLinks(offset: number, callback?: (numberOfResources: number) => void): void {\n\n    this.loading = true;\n\n    this._incomingService.getIncomingLinksForResource(this.sequence.resources[0].id, offset).subscribe(\n        (incomingResources: ReadResourcesSequence) => {\n            // update ontology information\n            this.ontologyInfo.updateOntologyInformation(incomingResources.ontologyInformation);\n\n            // Append elements incomingResources to this.sequence.incomingLinks\n            Array.prototype.push.apply(this.sequence.resources[0].incomingLinks, incomingResources.resources);\n\n            // if callback is given, execute function with the amount of incoming resources as the parameter\n            if (callback !== undefined) {\n                callback(incomingResources.resources.length);\n            }\n\n            this.loading = false;\n        },\n        (error: any) => {\n            console.error(error);\n            this.loading = false;\n        }\n    );\n}\n\nopenLink(id: string) {\n\n    this.loading = true;\n    // this.routeChanged.emit(id);\n    this._router.navigate(['/resource/' + encodeURIComponent(id)]);\n\n}\n\nrefreshProperties(index: number) {\n    // console.log('from still-image-component: ', index);\n    this.currentResource = this.sequence.resources[0].incomingFileRepresentations[index];\n    // console.log(this.currentResource);\n}\n\n\n\n\n\n}",
    "ctx": {
      "type": "method",
      "name": "getIncomingLinks",
      "string": "getIncomingLinks()"
    }
  }
]