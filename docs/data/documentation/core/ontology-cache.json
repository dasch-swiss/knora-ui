[
  {
    "tags": [],
    "description": {
      "full": "<p>Represents an error occurred in OntologyCacheService.</p>",
      "summary": "<p>Represents an error occurred in OntologyCacheService.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10,
    "codeStart": 13,
    "code": "class OntologyCacheError extends Error {\n\n    constructor(readonly message: string) {\n        super(message);\n    }\n}",
    "ctx": {
      "type": "class",
      "constructor": "OntologyCacheError",
      "cons": "OntologyCacheError",
      "name": "OntologyCacheError",
      "extends": "Error",
      "string": "new OntologyCacheError()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Represents an ontology's metadata.</p>",
      "summary": "<p>Represents an ontology's metadata.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 21,
    "codeStart": 24,
    "code": "export class OntologyMetadata {",
    "ctx": {
      "type": "class",
      "constructor": "OntologyMetadata",
      "cons": "OntologyMetadata",
      "name": "OntologyMetadata",
      "extends": "",
      "string": "new OntologyMetadata()"
    }
  },
  {
    "tags": [
      {
        "type": "hideconstructor",
        "string": "",
        "html": ""
      },
      {
        "type": "param",
        "string": "{string} id Iri identifying the ontology.",
        "name": "id",
        "description": "<p>Iri identifying the ontology.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} label a label describing the ontology.",
        "name": "label",
        "description": "<p>a label describing the ontology.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 26,
    "codeStart": 32,
    "code": "constructor(readonly id: string,\n    readonly label: string) {\n\n}\n\n}",
    "ctx": {
      "type": "constructor",
      "constructor": "OntologyMetadata",
      "cons": "OntologyMetadata",
      "name": "constructor",
      "string": "OntologyMetadata.prototype.constructor()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Occurrence of a property for a resource class (its cardinality).</p>",
      "summary": "<p>Occurrence of a property for a resource class (its cardinality).</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 40,
    "codeStart": 43,
    "code": "export enum CardinalityOccurrence {\n    minCard = 0,\n    card = 1,\n    maxCard = 2\n}",
    "ctx": false
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Cardinality of a property for the given resource class.</p>",
      "summary": "<p>Cardinality of a property for the given resource class.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 50,
    "codeStart": 53,
    "code": "export class Cardinality {",
    "ctx": {
      "type": "class",
      "constructor": "Cardinality",
      "cons": "Cardinality",
      "name": "Cardinality",
      "extends": "",
      "string": "new Cardinality()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{CardinalityOccurrence} occurrence type of given occurrence.",
        "name": "occurrence",
        "description": "<p>type of given occurrence.</p>",
        "types": [
          "CardinalityOccurrence"
        ],
        "typesDescription": "<a href=\"CardinalityOccurrence.html\">CardinalityOccurrence</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{number} value numerical value of given occurrence.",
        "name": "value",
        "description": "<p>numerical value of given occurrence.</p>",
        "types": [
          "number"
        ],
        "typesDescription": "<code>number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} property the property the given occurrence applies to.",
        "name": "property",
        "description": "<p>the property the given occurrence applies to.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 55,
    "codeStart": 60,
    "code": "constructor(readonly occurrence: CardinalityOccurrence,\n    readonly value: number,\n    readonly property: string) {\n}\n}",
    "ctx": {
      "type": "constructor",
      "constructor": "Cardinality",
      "cons": "Cardinality",
      "name": "constructor",
      "string": "Cardinality.prototype.constructor()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>A resource class definition.</p>",
      "summary": "<p>A resource class definition.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 67,
    "codeStart": 70,
    "code": "export class ResourceClass {",
    "ctx": {
      "type": "class",
      "constructor": "ResourceClass",
      "cons": "ResourceClass",
      "name": "ResourceClass",
      "extends": "",
      "string": "new ResourceClass()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string} id Iri identifying the resource class.",
        "name": "id",
        "description": "<p>Iri identifying the resource class.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} icon path to an icon representing the resource class.",
        "name": "icon",
        "description": "<p>path to an icon representing the resource class.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} comment comment on the resource class.",
        "name": "comment",
        "description": "<p>comment on the resource class.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} label label describing the resource class.",
        "name": "label",
        "description": "<p>label describing the resource class.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Cardinality[]} cardinalities the resource class's properties.",
        "name": "cardinalities",
        "description": "<p>the resource class's properties.</p>",
        "types": [
          "Array.<Cardinality>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<a href=\"Cardinality.html\">Cardinality</a>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 72,
    "codeStart": 79,
    "code": "constructor(readonly id: string,\n    readonly icon: string,\n    readonly comment: string,\n    readonly label: string,\n    readonly cardinalities: Array<Cardinality>) {\n\n}\n}",
    "ctx": {
      "type": "constructor",
      "constructor": "ResourceClass",
      "cons": "ResourceClass",
      "name": "constructor",
      "string": "ResourceClass.prototype.constructor()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>A map of resource class Iris to resource class definitions.</p>",
      "summary": "<p>A map of resource class Iris to resource class definitions.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 89,
    "codeStart": 92,
    "code": "export class ResourceClasses {\n    [index: string]: ResourceClass;\n}",
    "ctx": {
      "type": "class",
      "constructor": "ResourceClasses",
      "cons": "ResourceClasses",
      "name": "ResourceClasses",
      "extends": "",
      "string": "new ResourceClasses()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>A property definition.</p>",
      "summary": "<p>A property definition.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 97,
    "codeStart": 100,
    "code": "export class Property {",
    "ctx": {
      "type": "class",
      "constructor": "Property",
      "cons": "Property",
      "name": "Property",
      "extends": "",
      "string": "new Property()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string} id Iri identifying the property definition.",
        "name": "id",
        "description": "<p>Iri identifying the property definition.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} objectType the property's object constraint.",
        "name": "objectType",
        "description": "<p>the property's object constraint.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} comment comment on the property definition.",
        "name": "comment",
        "description": "<p>comment on the property definition.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} label label describing the property definition.",
        "name": "label",
        "description": "<p>label describing the property definition.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string[]} subPropertyOf Iris of properties the given property is a subproperty of.",
        "name": "subPropertyOf",
        "description": "<p>Iris of properties the given property is a subproperty of.</p>",
        "types": [
          "Array.<string>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>string</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{boolean} isEditable indicates whether the given property can be edited by the client.",
        "name": "isEditable",
        "description": "<p>indicates whether the given property can be edited by the client.</p>",
        "types": [
          "boolean"
        ],
        "typesDescription": "<code>boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{boolean} isLinkProperty indicates whether the given property is a linking property.",
        "name": "isLinkProperty",
        "description": "<p>indicates whether the given property is a linking property.</p>",
        "types": [
          "boolean"
        ],
        "typesDescription": "<code>boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{boolean} isLinkValueProperty indicates whether the given property refers to a link value.",
        "name": "isLinkValueProperty",
        "description": "<p>indicates whether the given property refers to a link value.</p>",
        "types": [
          "boolean"
        ],
        "typesDescription": "<code>boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 102,
    "codeStart": 112,
    "code": "constructor(readonly id: string,\n    readonly objectType: string,\n    readonly comment: string,\n    readonly label: string,\n    readonly subPropertyOf: Array<string>,\n    readonly isEditable: Boolean,\n    readonly isLinkProperty: Boolean,\n    readonly isLinkValueProperty: Boolean) {\n\n}\n}",
    "ctx": {
      "type": "constructor",
      "constructor": "Property",
      "cons": "Property",
      "name": "constructor",
      "string": "Property.prototype.constructor()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>A map of property Iris to property definitions.</p>",
      "summary": "<p>A map of property Iris to property definitions.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 125,
    "codeStart": 128,
    "code": "export class Properties {\n    [index: string]: Property;\n}",
    "ctx": {
      "type": "class",
      "constructor": "Properties",
      "cons": "Properties",
      "name": "Properties",
      "extends": "",
      "string": "new Properties()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Groups resource classes by the ontology they are defined in.</p>\n<p>A map of ontology Iris to an array of resource class Iris.</p>",
      "summary": "<p>Groups resource classes by the ontology they are defined in.</p>",
      "body": "<p>A map of ontology Iris to an array of resource class Iris.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 133,
    "codeStart": 138,
    "code": "export class ResourceClassIrisForOntology {\n    [index: string]: Array<string>;\n}",
    "ctx": {
      "type": "class",
      "constructor": "ResourceClassIrisForOntology",
      "cons": "ResourceClassIrisForOntology",
      "name": "ResourceClassIrisForOntology",
      "extends": "",
      "string": "new ResourceClassIrisForOntology()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Represents cached ontology information (only used by this service internally).<br />\nThis cache is updated whenever new definitions are requested from Knora.</p>\n<p>Requested ontology information by a service is represented by [[OntologyInformation]].</p>",
      "summary": "<p>Represents cached ontology information (only used by this service internally).<br />\nThis cache is updated whenever new definitions are requested from Knora.</p>",
      "body": "<p>Requested ontology information by a service is represented by [[OntologyInformation]].</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 143,
    "codeStart": 149,
    "code": "class OntologyCache {",
    "ctx": {
      "type": "class",
      "constructor": "OntologyCache",
      "cons": "OntologyCache",
      "name": "OntologyCache",
      "extends": "",
      "string": "new OntologyCache()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{OntologyMetadata[]} ontologies An array of all existing ontologies.",
        "name": "ontologies",
        "description": "<p>An array of all existing ontologies.</p>",
        "types": [
          "Array.<OntologyMetadata>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<a href=\"OntologyMetadata.html\">OntologyMetadata</a>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 151,
    "codeStart": 154,
    "code": "ontologies: Array<OntologyMetadata>;",
    "ctx": {
      "type": "property",
      "constructor": "OntologyCache",
      "cons": "OntologyCache",
      "name": "ontologies",
      "value": "Array<OntologyMetadata>",
      "string": "OntologyCache.ontologies"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{ResourceClassIrisForOntology} resourceClassIrisForOntology list of all resource class Iris for a named graph.",
        "name": "resourceClassIrisForOntology",
        "description": "<p>list of all resource class Iris for a named graph.</p>",
        "types": [
          "ResourceClassIrisForOntology"
        ],
        "typesDescription": "<a href=\"ResourceClassIrisForOntology.html\">ResourceClassIrisForOntology</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 156,
    "codeStart": 159,
    "code": "resourceClassIrisForOntology: ResourceClassIrisForOntology;",
    "ctx": {
      "type": "property",
      "constructor": "OntologyCache",
      "cons": "OntologyCache",
      "name": "resourceClassIrisForOntology",
      "value": "ResourceClassIrisForOntology",
      "string": "OntologyCache.resourceClassIrisForOntology"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{ResourceClasses} resourceClasses resource class definitions.",
        "name": "resourceClasses",
        "description": "<p>resource class definitions.</p>",
        "types": [
          "ResourceClasses"
        ],
        "typesDescription": "<a href=\"ResourceClasses.html\">ResourceClasses</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 161,
    "codeStart": 164,
    "code": "resourceClasses: ResourceClasses;",
    "ctx": {
      "type": "property",
      "constructor": "OntologyCache",
      "cons": "OntologyCache",
      "name": "resourceClasses",
      "value": "ResourceClasses",
      "string": "OntologyCache.resourceClasses"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Properties} properties property definitions.",
        "name": "properties",
        "description": "<p>property definitions.</p>",
        "types": [
          "Properties"
        ],
        "typesDescription": "<a href=\"Properties.html\">Properties</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 166,
    "codeStart": 169,
    "code": "properties: Properties;\n\nconstructor() {\n    this.ontologies = [];\n\n    this.resourceClassIrisForOntology = new ResourceClassIrisForOntology();\n\n    this.resourceClasses = new ResourceClasses();\n\n    this.properties = new Properties();\n}\n}",
    "ctx": {
      "type": "property",
      "constructor": "OntologyCache",
      "cons": "OntologyCache",
      "name": "properties",
      "value": "Properties",
      "string": "OntologyCache.properties"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Represents ontology information requested from this service.</p>\n<p>For every request, an instance of this class is returned containing the requested information.</p>",
      "summary": "<p>Represents ontology information requested from this service.</p>",
      "body": "<p>For every request, an instance of this class is returned containing the requested information.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 182,
    "codeStart": 187,
    "code": "export class OntologyInformation {",
    "ctx": {
      "type": "class",
      "constructor": "OntologyInformation",
      "cons": "OntologyInformation",
      "name": "OntologyInformation",
      "extends": "",
      "string": "new OntologyInformation()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{ResourceClassIrisForOntology} resourceClassesForOntology all resource class Iris for a given ontology.",
        "name": "resourceClassesForOntology",
        "description": "<p>all resource class Iris for a given ontology.</p>",
        "types": [
          "ResourceClassIrisForOntology"
        ],
        "typesDescription": "<a href=\"ResourceClassIrisForOntology.html\">ResourceClassIrisForOntology</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{ResourceClasses} resourceClasses resource class definitions.",
        "name": "resourceClasses",
        "description": "<p>resource class definitions.</p>",
        "types": [
          "ResourceClasses"
        ],
        "typesDescription": "<a href=\"ResourceClasses.html\">ResourceClasses</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Properties} properties property definitions.",
        "name": "properties",
        "description": "<p>property definitions.</p>",
        "types": [
          "Properties"
        ],
        "typesDescription": "<a href=\"Properties.html\">Properties</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 189,
    "codeStart": 194,
    "code": "constructor(\n    private resourceClassesForOntology: ResourceClassIrisForOntology,\n    private resourceClasses: ResourceClasses,\n    private properties: Properties) {\n}",
    "ctx": {
      "type": "constructor",
      "constructor": "OntologyInformation",
      "cons": "OntologyInformation",
      "name": "constructor",
      "string": "OntologyInformation.prototype.constructor()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{OntologyInformation} ontologyInfo the given definitions that have to be integrated.",
        "name": "ontologyInfo",
        "description": "<p>the given definitions that have to be integrated.</p>",
        "types": [
          "OntologyInformation"
        ],
        "typesDescription": "<a href=\"OntologyInformation.html\">OntologyInformation</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "void",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>void</p>"
      }
    ],
    "description": {
      "full": "<p>Merge the given [[OntologyInformation]] into the current instance,<br />\nupdating the existing information.<br />\nThis is necessary when a service like the search fetches new results<br />\nthat have to be added to an existing collection.<br />\nThe existing ontology information must not be lost.</p>",
      "summary": "<p>Merge the given [[OntologyInformation]] into the current instance,<br />\nupdating the existing information.<br />\nThis is necessary when a service like the search fetches new results<br />\nthat have to be added to an existing collection.<br />\nThe existing ontology information must not be lost.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 200,
    "codeStart": 210,
    "code": "updateOntologyInformation(ontologyInfo: OntologyInformation): void {\n\n    // get new resourceClassIrisForOntology\n    const newResourceClassesForOntology: ResourceClassIrisForOntology = ontologyInfo.getResourceClassForOntology();\n\n    // update new resourceClassIrisForOntology\n    // tslint:disable-next-line:forin\n    for (const newResClassForOntology in newResourceClassesForOntology) {\n        this.resourceClassesForOntology[newResClassForOntology] = newResourceClassesForOntology[newResClassForOntology];\n    }\n\n    // get new resource class definitions\n    const newResourceClasses = ontologyInfo.getResourceClasses();\n\n    // update resourceClasses\n    // tslint:disable-next-line:forin\n    for (const newResClass in newResourceClasses) {\n        this.resourceClasses[newResClass] = newResourceClasses[newResClass];\n    }\n\n    // get new property definitions\n    const newProperties = ontologyInfo.getProperties();\n\n    // update properties\n    // tslint:disable-next-line:forin\n    for (const newProp in newProperties) {\n        this.properties[newProp] = newProperties[newProp];\n    }\n\n}",
    "ctx": {
      "type": "method",
      "constructor": "OntologyInformation",
      "cons": "OntologyInformation",
      "name": "updateOntologyInformation",
      "string": "OntologyInformation.prototype.updateOntologyInformation()"
    }
  },
  {
    "tags": [
      {
        "type": "returns",
        "string": "ResourceClassIrisForOntology - all resource class definitions grouped by ontologies.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>ResourceClassIrisForOntology - all resource class definitions grouped by ontologies.</p>"
      }
    ],
    "description": {
      "full": "<p>Returns resource class definitions for ontologies.</p>",
      "summary": "<p>Returns resource class definitions for ontologies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 241,
    "codeStart": 246,
    "code": "getResourceClassForOntology(): ResourceClassIrisForOntology {\n    return this.resourceClassesForOntology;\n}",
    "ctx": {
      "type": "method",
      "constructor": "OntologyInformation",
      "cons": "OntologyInformation",
      "name": "getResourceClassForOntology",
      "string": "OntologyInformation.prototype.getResourceClassForOntology()"
    }
  },
  {
    "tags": [
      {
        "type": "returns",
        "string": "ResourceClasses - all resource class definitions as an object.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>ResourceClasses - all resource class definitions as an object.</p>"
      }
    ],
    "description": {
      "full": "<p>Returns all resource classes as an object.</p>",
      "summary": "<p>Returns all resource classes as an object.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 250,
    "codeStart": 255,
    "code": "getResourceClasses(): ResourceClasses {\n    return this.resourceClasses;\n}",
    "ctx": {
      "type": "method",
      "constructor": "OntologyInformation",
      "cons": "OntologyInformation",
      "name": "getResourceClasses",
      "string": "OntologyInformation.prototype.getResourceClasses()"
    }
  },
  {
    "tags": [
      {
        "type": "returns",
        "string": "ResourceClass[]",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>ResourceClass[]</p>"
      }
    ],
    "description": {
      "full": "<p>Returns all resource classes as an array.</p>",
      "summary": "<p>Returns all resource classes as an array.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 259,
    "codeStart": 264,
    "code": "getResourceClassesAsArray(): Array<ResourceClass> {\n\n    const resClasses: Array<ResourceClass> = [];\n\n    // tslint:disable-next-line:forin\n    for (const resClassIri in this.resourceClasses) {\n        const resClass: ResourceClass = this.resourceClasses[resClassIri];\n        resClasses.push(resClass);\n    }\n\n    return resClasses;\n\n}",
    "ctx": {
      "type": "method",
      "constructor": "OntologyInformation",
      "cons": "OntologyInformation",
      "name": "getResourceClassesAsArray",
      "string": "OntologyInformation.prototype.getResourceClassesAsArray()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string} resClass resource class to query for.",
        "name": "resClass",
        "description": "<p>resource class to query for.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "string - the resource class's label.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>string - the resource class's label.</p>"
      }
    ],
    "description": {
      "full": "<p>Returns a resource class's label.</p>",
      "summary": "<p>Returns a resource class's label.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 278,
    "codeStart": 284,
    "code": "getLabelForResourceClass(resClass: string): string {\n\n    if (resClass !== undefined) {\n\n        const resClassDef = this.resourceClasses[resClass];\n\n        if (resClassDef !== undefined && resClassDef.label !== undefined) {\n            return resClassDef.label;\n        } else {\n            return resClassDef.id;\n        }\n    } else {\n        console.log('call of OntologyInformation.getLabelForResourceClass without argument resClass');\n    }\n}",
    "ctx": {
      "type": "method",
      "constructor": "OntologyInformation",
      "cons": "OntologyInformation",
      "name": "getLabelForResourceClass",
      "string": "OntologyInformation.prototype.getLabelForResourceClass()"
    }
  },
  {
    "tags": [
      {
        "type": "returns",
        "string": "Properties - all properties as an object.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Properties - all properties as an object.</p>"
      }
    ],
    "description": {
      "full": "<p>Returns all properties as an object.</p>",
      "summary": "<p>Returns all properties as an object.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 300,
    "codeStart": 305,
    "code": "getProperties(): Properties {\n    return this.properties;\n}",
    "ctx": {
      "type": "method",
      "constructor": "OntologyInformation",
      "cons": "OntologyInformation",
      "name": "getProperties",
      "string": "OntologyInformation.prototype.getProperties()"
    }
  },
  {
    "tags": [
      {
        "type": "returns",
        "string": "Property[] - all properties as an array.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Property[] - all properties as an array.</p>"
      }
    ],
    "description": {
      "full": "<p>Returns all properties as an array.</p>",
      "summary": "<p>Returns all properties as an array.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 309,
    "codeStart": 314,
    "code": "getPropertiesAsArray(): Array<Property> {\n\n    const properties: Array<Property> = [];\n\n    // tslint:disable-next-line:forin\n    for (const propIri in this.properties) {\n        const prop: Property = this.properties[propIri];\n        properties.push(prop);\n    }\n\n    return properties;\n\n}",
    "ctx": {
      "type": "method",
      "constructor": "OntologyInformation",
      "cons": "OntologyInformation",
      "name": "getPropertiesAsArray",
      "string": "OntologyInformation.prototype.getPropertiesAsArray()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string} property to query for.",
        "name": "property",
        "description": "<p>to query for.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "string - the property's label.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>string - the property's label.</p>"
      }
    ],
    "description": {
      "full": "<p>Returns a property's label.</p>",
      "summary": "<p>Returns a property's label.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 328,
    "codeStart": 334,
    "code": "getLabelForProperty(property: string): string {\n\n    if (property !== undefined) {\n\n        const propDef = this.properties[property];\n\n        if (propDef !== undefined && propDef.label !== undefined) {\n            return propDef.label;\n        } else {\n            return propDef.id;\n        }\n    } else {\n        console.log('call of OntologyInformation.getLabelForProperty without argument property');\n    }\n}\n\n}",
    "ctx": {
      "type": "method",
      "constructor": "OntologyInformation",
      "cons": "OntologyInformation",
      "name": "getLabelForProperty",
      "string": "OntologyInformation.prototype.getLabelForProperty()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Requests ontology information from Knora and caches it.<br />\nOther components or services obtain ontology information through this service.</p>",
      "summary": "<p>Requests ontology information from Knora and caches it.<br />\nOther components or services obtain ontology information through this service.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 353,
    "codeStart": 357,
    "code": "@Injectable({\n    providedIn: 'root'\n})\nexport class OntologyCacheService {",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string[]} excludedOntologies",
        "name": "excludedOntologies",
        "description": "",
        "types": [
          "Array.<string>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>string</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{string[]} excludedOntologies</p>"
      }
    ],
    "description": {
      "full": "<p>Ontologies ingored by this service.</p>",
      "summary": "<p>Ontologies ingored by this service.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 362,
    "codeStart": 366,
    "code": "private excludedOntologies: Array<string> = [KnoraConstants.SalsahGuiOntology, KnoraConstants.StandoffOntology];",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string[]} excludedProperties properties that Knora is not responsible for and that have to be ignored because they cannot be resolved at the moment.",
        "name": "excludedProperties",
        "description": "<p>properties that Knora is not responsible for and that have to be ignored because they cannot be resolved at the moment.</p>",
        "types": [
          "Array.<string>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>string</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 368,
    "codeStart": 371,
    "code": "private excludedProperties: Array<string> = [KnoraConstants.RdfsLabel];",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string[]} nonResourceClasses class definitions that are not be treated as Knora resource classes",
        "name": "nonResourceClasses",
        "description": "<p>class definitions that are not be treated as Knora resource classes</p>",
        "types": [
          "Array.<string>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>string</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 373,
    "codeStart": 376,
    "code": "private nonResourceClasses: Array<string> = [KnoraConstants.ForbiddenResource, KnoraConstants.XMLToStandoffMapping, KnoraConstants.ListNode];",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{OntologyCache} cacheOntology central instance that caches all definitions",
        "name": "cacheOntology",
        "description": "<p>central instance that caches all definitions</p>",
        "types": [
          "OntologyCache"
        ],
        "typesDescription": "<a href=\"OntologyCache.html\">OntologyCache</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 378,
    "codeStart": 381,
    "code": "private cacheOntology: OntologyCache = new OntologyCache();\n\nconstructor(private _ontologyService: OntologyService) {\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "returns",
        "string": "Observable<object> - metadata for all ontologies as JSON-LD (no prefixes, all Iris fully expanded).",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Observable<object> - metadata for all ontologies as JSON-LD (no prefixes, all Iris fully expanded).</p>"
      }
    ],
    "description": {
      "full": "<p>Requests the metadata of all ontologies from Knora.</p>",
      "summary": "<p>Requests the metadata of all ontologies from Knora.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 386,
    "codeStart": 391,
    "code": "private getOntologiesMetadataFromKnora(): Observable<object> {\n\n    return this._ontologyService.getOntologiesMetadata().pipe(\n        mergeMap(\n            // this would return an Observable of a PromiseObservable -> combine them into one Observable\n            // http://reactivex.io/documentation/operators/flatmap.html\n            // http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeMap\n            (ontRes: ApiServiceResult) => {\n                const ontPromises = jsonld.promises;\n                // compact JSON-LD using an empty context: expands all Iris\n                const ontPromise = ontPromises.compact(ontRes.body, {});\n\n                // convert promise to Observable and return it\n                // https://www.learnrxjs.io/operators/creation/frompromise.html\n                return from(ontPromise);\n            }\n        )\n    );\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string} ontologyIri the Iri of the requested ontology.",
        "name": "ontologyIri",
        "description": "<p>the Iri of the requested ontology.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "Observable<object> - metadata for all entity definitions for ontology from Knora.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Observable<object> - metadata for all entity definitions for ontology from Knora.</p>"
      }
    ],
    "description": {
      "full": "<p>Requests all entity definitions (resource classes and properties) for the given ontology from Knora.</p>",
      "summary": "<p>Requests all entity definitions (resource classes and properties) for the given ontology from Knora.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 411,
    "codeStart": 417,
    "code": "private getAllEntityDefinitionsForOntologyFromKnora(ontologyIri: string): Observable<object> {\n\n    return this._ontologyService.getAllEntityDefinitionsForOntologies(ontologyIri).pipe(\n        mergeMap(\n            // this would return an Observable of a PromiseObservable -> combine them into one Observable\n            // http://reactivex.io/documentation/operators/flatmap.html\n            // http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeMap\n            (ontRes: ApiServiceResult) => {\n                const ontPromises = jsonld.promises;\n                // compact JSON-LD using an empty context: expands all Iris\n                const ontPromise = ontPromises.compact(ontRes.body, {});\n\n                // convert promise to Observable and return it\n                // https://www.learnrxjs.io/operators/creation/frompromise.html\n                return from(ontPromise);\n            }\n        )\n    );\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{object[]} ontologies metadata of all existing ontologies as JSON-LD.",
        "name": "ontologies",
        "description": "<p>metadata of all existing ontologies as JSON-LD.</p>",
        "types": [
          "Array.<object>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>object</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "a new OntologyMetadata object",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>a new OntologyMetadata object</p>"
      }
    ],
    "description": {
      "full": "<p>Writes all the ontologies' metadata returned by Knora to the cache.</p>",
      "summary": "<p>Writes all the ontologies' metadata returned by Knora to the cache.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 437,
    "codeStart": 443,
    "code": "private convertAndWriteOntologiesMetadataToCache(ontologies: object[]) {\n\n    this.cacheOntology.ontologies = ontologies.map(\n        ontology => {\n            return new OntologyMetadata(ontology['@id'], ontology[KnoraConstants.RdfsLabel]);\n        }\n    );\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "returns",
        "string": "Array<OntologyMetadata> - metadata of all existing ontologies.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Array<OntologyMetadata> - metadata of all existing ontologies.</p>"
      }
    ],
    "description": {
      "full": "<p>Returns all ontologies' metadata from the cache and returns them.</p>",
      "summary": "<p>Returns all ontologies' metadata from the cache and returns them.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 452,
    "codeStart": 457,
    "code": "private getAllOntologiesMetadataFromCache(): Array<OntologyMetadata> {\n\n    return this.cacheOntology.ontologies;\n\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Array<object>} classDefinitions the class definitions in an ontology response.",
        "name": "classDefinitions",
        "description": "<p>the class definitions in an ontology response.</p>",
        "types": [
          "Array.<object>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>object</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "string[] - resource class Iris from the given class definitions.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>string[] - resource class Iris from the given class definitions.</p>"
      }
    ],
    "description": {
      "full": "<p>Returns resource class Iris from the ontology response.<br />\n<code>knora-api:Resource</code> will be excluded.</p>",
      "summary": "<p>Returns resource class Iris from the ontology response.<br />\n<code>knora-api:Resource</code> will be excluded.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 463,
    "codeStart": 470,
    "code": "private getResourceClassIrisFromOntologyResponse(classDefinitions: Array<object>): string[] {\n    const resourceClassIris: string[] = [];\n\n    for (const classDef of classDefinitions) {\n        const classIri = classDef['@id'];\n\n        // check that class name is not listed as a non resource class and that the isResourceClass flag is present and set to true\n        if (\n            classIri !== KnoraConstants.Resource && this.nonResourceClasses.indexOf(classIri)\n            === -1 && (classDef[KnoraConstants.IsResourceClass] !== undefined && classDef[KnoraConstants.IsResourceClass] === true)) {\n            // it is not a value class, but a resource class definition\n            resourceClassIris.push(classIri);\n        }\n    }\n\n    return resourceClassIris;\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} ontology the ontology to be cached.",
        "name": "ontology",
        "description": "<p>the ontology to be cached.</p>",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "void",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>void</p>"
      }
    ],
    "description": {
      "full": "<p>Converts a Knora response for all entity definitions for the requested ontology<br />\ninto an internal representation and caches it.</p>\n<p>Knora automatically includes the property definitions referred to in the cardinalities of resource classes.<br />\nIf they are defined in another ontology, that ontology is requested from Knora too.</p>",
      "summary": "<p>Converts a Knora response for all entity definitions for the requested ontology<br />\ninto an internal representation and caches it.</p>",
      "body": "<p>Knora automatically includes the property definitions referred to in the cardinalities of resource classes.<br />\nIf they are defined in another ontology, that ontology is requested from Knora too.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 488,
    "codeStart": 498,
    "code": "private convertAndWriteAllEntityDefinitionsForOntologyToCache(ontology: object): void {\n\n    const graph = ontology['@graph'];\n\n    // get all class definitions\n    const classDefs = graph.filter(\n        (entity: Object) => {\n            const entityType = entity['@type'];\n            return entityType === KnoraConstants.OwlClass;\n        });\n\n    // get all property definitions\n    const propertyDefs = graph.filter(\n        (entity: Object) => {\n            const entityType = entity['@type'];\n            return entityType === KnoraConstants.OwlObjectProperty ||\n                entityType === KnoraConstants.OwlDatatypeProperty ||\n                entityType === KnoraConstants.OwlAnnotationProperty ||\n                entityType === KnoraConstants.RdfProperty;\n        });\n\n\n    // cache all resource class Iris belonging to the current ontology\n    this.cacheOntology.resourceClassIrisForOntology[ontology['@id']] = this.getResourceClassIrisFromOntologyResponse(classDefs);\n\n    // write class and property defintions to cache\n    this.convertAndWriteEntityDefinitionsToCache(classDefs, propertyDefs);\n\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string[]} ontologyIris the ontologies for which definitions should be returned.",
        "name": "ontologyIris",
        "description": "<p>the ontologies for which definitions should be returned.</p>",
        "types": [
          "Array.<string>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>string</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "Observable<OntologyInformation> - the definitions for the requested ontologies.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Observable<OntologyInformation> - the definitions for the requested ontologies.</p>"
      }
    ],
    "description": {
      "full": "<p>Returns definitions for the requested ontologies from the cache.</p>",
      "summary": "<p>Returns definitions for the requested ontologies from the cache.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 528,
    "codeStart": 534,
    "code": "private getOntologyInformationFromCache(ontologyIris: string[]): Observable<OntologyInformation> {\n\n    const resourceClassesForOntology = new ResourceClassIrisForOntology();\n\n    // collect resource class Iris for all requested named graphs\n    let allResourceClassIris = [];\n\n    for (const ontologyIri of ontologyIris) {\n\n        if (this.cacheOntology.resourceClassIrisForOntology[ontologyIri] === undefined) {\n            throw new OntologyCacheError(`getResourceClassesForOntologiesFromCache: ontology not found in cache: ${ontologyIri}`);\n        }\n\n        // add information for the given ontology\n        resourceClassesForOntology[ontologyIri] = this.cacheOntology.resourceClassIrisForOntology[ontologyIri];\n\n        // add all resource class Iris of this ontology\n        allResourceClassIris = allResourceClassIris.concat(this.cacheOntology.resourceClassIrisForOntology[ontologyIri]);\n    }\n\n    // get resource class definitions for all requested ontologies\n    return this.getResourceClassDefinitions(allResourceClassIris).pipe(\n        map(\n            resClassDefs => {\n                return new OntologyInformation(\n                    resourceClassesForOntology, resClassDefs.getResourceClasses(), resClassDefs.getProperties()\n                );\n            }\n        )\n    );\n\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{object[]} resourceClassDefinitions the resource class definitions returned by Knora.",
        "name": "resourceClassDefinitions",
        "description": "<p>the resource class definitions returned by Knora.</p>",
        "types": [
          "Array.<object>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>object</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object[]} propertyClassDefinitions the property definitions returned by Knora.",
        "name": "propertyClassDefinitions",
        "description": "<p>the property definitions returned by Knora.</p>",
        "types": [
          "Array.<object>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>object</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "void",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>void</p>"
      }
    ],
    "description": {
      "full": "<p>Converts a Knora ontology response into an internal representation and caches it.</p>",
      "summary": "<p>Converts a Knora ontology response into an internal representation and caches it.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 567,
    "codeStart": 574,
    "code": "private convertAndWriteEntityDefinitionsToCache(resourceClassDefinitions: Array<object>, propertyClassDefinitions: Array<object>): void {\n\n    // convert and cache each given resource class definition\n    for (const resClass of resourceClassDefinitions) {\n\n        const resClassIri = resClass['@id'];\n\n        // represents all cardinalities of this resource class\n        const cardinalities: Cardinality[] = [];\n\n        if (resClass[KnoraConstants.RdfsSubclassOf] !== undefined) {\n\n            let subclassOfCollection;\n\n            // check if it is a single object or a collection\n            if (!Array.isArray(resClass[KnoraConstants.RdfsSubclassOf])) {\n                subclassOfCollection = [resClass[KnoraConstants.RdfsSubclassOf]];\n            } else {\n                subclassOfCollection = resClass[KnoraConstants.RdfsSubclassOf];\n            }\n\n            // get cardinalities for the properties of a resource class\n            for (const curCard of subclassOfCollection) {\n\n                // make sure it is a cardinality (it could also be an Iri of a superclass)\n                if (curCard instanceof Object && curCard['@type'] !== undefined && curCard['@type'] === KnoraConstants.OwlRestriction) {\n\n                    let newCard;\n\n                    // get occurrence\n                    if (curCard[KnoraConstants.OwlMinCardinality] !== undefined) {\n                        newCard = new Cardinality(CardinalityOccurrence.minCard, curCard[KnoraConstants.OwlMinCardinality], curCard[KnoraConstants.OwlOnProperty]['@id']);\n                    } else if (curCard[KnoraConstants.OwlCardinality] !== undefined) {\n                        newCard = new Cardinality(CardinalityOccurrence.card, curCard[KnoraConstants.OwlCardinality], curCard[KnoraConstants.OwlOnProperty]['@id']);\n                    } else if (curCard[KnoraConstants.OwlMaxCardinality] !== undefined) {\n                        newCard = new Cardinality(CardinalityOccurrence.maxCard, curCard[KnoraConstants.OwlMaxCardinality], curCard[KnoraConstants.OwlOnProperty]['@id']);\n                    } else {\n                        // no known occurrence found\n                        throw new TypeError(`cardinality type invalid for ${resClass['@id']} ${curCard[KnoraConstants.OwlOnProperty]}`);\n                    }\n\n                    // TODO: get gui order\n\n\n                    // add cardinality\n                    cardinalities.push(newCard);\n\n                }\n\n            }\n        }\n\n        const resClassObj = new ResourceClass(\n            resClassIri,\n            resClass[KnoraConstants.ResourceIcon],\n            resClass[KnoraConstants.RdfsComment],\n            resClass[KnoraConstants.RdfsLabel],\n            cardinalities\n        );\n\n        // write this resource class definition to the cache object\n        this.cacheOntology.resourceClasses[resClassIri] = resClassObj;\n    }\n\n    // cache the property definitions\n    this.convertAndWriteKnoraPropertyDefinitionsToOntologyCache(propertyClassDefinitions);\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string[]} resClassIris the given resource class Iris",
        "name": "resClassIris",
        "description": "<p>the given resource class Iris</p>",
        "types": [
          "Array.<string>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>string</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "Observable<OntologyInformation> - an [[OntologyCache]] representing the requested resource classes.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Observable<OntologyInformation> - an [[OntologyCache]] representing the requested resource classes.</p>"
      }
    ],
    "description": {
      "full": "<p>Gets information about resource classes from the cache.<br />\nThe answer includes the property definitions referred to by the cardinalities of the given resource classes.</p>",
      "summary": "<p>Gets information about resource classes from the cache.<br />\nThe answer includes the property definitions referred to by the cardinalities of the given resource classes.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 642,
    "codeStart": 649,
    "code": "private getResourceClassDefinitionsFromCache(resClassIris: string[]): Observable<OntologyInformation> {\n    // collect the definitions for each resource class from the cache\n\n    const resClassDefs = new ResourceClasses();\n\n    // collect the properties from the cardinalities of the given resource classes\n    const propertyIris = [];\n\n    resClassIris.forEach(\n        resClassIri => {\n            resClassDefs[resClassIri] = this.cacheOntology.resourceClasses[resClassIri];\n\n            this.cacheOntology.resourceClasses[resClassIri].cardinalities.forEach(\n                card => {\n                    // get property definition for each cardinality\n                    propertyIris.push(card.property);\n                }\n            );\n        });\n\n    return this.getPropertyDefinitions(propertyIris).pipe(\n        map(\n            propDefs => {\n                return new OntologyInformation(new ResourceClassIrisForOntology(), resClassDefs, propDefs.getProperties());\n            }\n        )\n    );\n\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{object[]} propertyDefinitionsFromKnora the property definitions returned by Knora",
        "name": "propertyDefinitionsFromKnora",
        "description": "<p>the property definitions returned by Knora</p>",
        "types": [
          "Array.<object>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>object</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "void",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>void</p>"
      }
    ],
    "description": {
      "full": "<p>Converts a Knora response for ontology information about properties<br />\ninto an internal representation and cache it.</p>",
      "summary": "<p>Converts a Knora response for ontology information about properties<br />\ninto an internal representation and cache it.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 679,
    "codeStart": 686,
    "code": "private convertAndWriteKnoraPropertyDefinitionsToOntologyCache(propertyDefinitionsFromKnora: Array<object>): void {\n\n    // convert and cache each given property definition\n    for (const propDef of propertyDefinitionsFromKnora) {\n\n        const propIri = propDef['@id'];\n\n        let isEditable = false;\n        if (propDef[KnoraConstants.isEditable] !== undefined && propDef[KnoraConstants.isEditable] === true) {\n            isEditable = true;\n        }\n\n        let isLinkProperty = false;\n        if (propDef[KnoraConstants.isLinkProperty] !== undefined && propDef[KnoraConstants.isLinkProperty] === true) {\n            isLinkProperty = true;\n        }\n\n        let isLinkValueProperty = false;\n        if (propDef[KnoraConstants.isLinkValueProperty] !== undefined && propDef[KnoraConstants.isLinkValueProperty] === true) {\n            isLinkValueProperty = true;\n        }\n\n        let subPropertyOf = [];\n        if (propDef[KnoraConstants.subPropertyOf] !== undefined && Array.isArray(propDef[KnoraConstants.subPropertyOf])) {\n            subPropertyOf = propDef[KnoraConstants.subPropertyOf].map((superProp: Object) => superProp['@id']);\n        } else if (propDef[KnoraConstants.subPropertyOf] !== undefined) {\n            subPropertyOf.push(propDef[KnoraConstants.subPropertyOf]['@id']);\n        }\n\n        let objectType;\n        if (propDef[KnoraConstants.ObjectType] !== undefined) {\n            objectType = propDef[KnoraConstants.ObjectType]['@id'];\n        }\n\n        // cache property definition\n        this.cacheOntology.properties[propIri] = new Property(\n            propIri,\n            objectType,\n            propDef[KnoraConstants.RdfsComment],\n            propDef[KnoraConstants.RdfsLabel],\n            subPropertyOf,\n            isEditable,\n            isLinkProperty,\n            isLinkValueProperty\n        );\n\n    }\n\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string[]} propertyIris the property definitions to be returned.",
        "name": "propertyIris",
        "description": "<p>the property definitions to be returned.</p>",
        "types": [
          "Array.<string>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>string</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "OntologyInformation - requested property defintions.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>OntologyInformation - requested property defintions.</p>"
      }
    ],
    "description": {
      "full": "<p>Returns property definitions from the cache.</p>",
      "summary": "<p>Returns property definitions from the cache.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 736,
    "codeStart": 742,
    "code": "private getPropertyDefinitionsFromCache(propertyIris: string[]): OntologyInformation {\n\n    const propertyDefs = new Properties();\n\n    propertyIris.forEach(\n        propIri => {\n            // ignore non Knora props: if propIri is contained in excludedProperties, skip this propIri\n            if (this.excludedProperties.indexOf(propIri) > -1) {\n                return;\n            }\n\n            if (this.cacheOntology.properties[propIri] === undefined) {\n                throw new OntologyCacheError(`getPropertyDefinitionsFromCache: property not found in cache: ${propIri}`);\n            }\n\n            propertyDefs[propIri] = this.cacheOntology.properties[propIri];\n        }\n    );\n\n    return new OntologyInformation(new ResourceClassIrisForOntology(), new ResourceClasses(), propertyDefs);\n\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "returns",
        "string": "Observable<Array<OntologyMetadata>> - metadata about all ontologies.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Observable&lt;Array<OntologyMetadata>&gt; - metadata about all ontologies.</p>"
      }
    ],
    "description": {
      "full": "<p>Returns metadata about all ontologies.</p>",
      "summary": "<p>Returns metadata about all ontologies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 765,
    "codeStart": 770,
    "code": "public getOntologiesMetadata(): Observable<Array<OntologyMetadata>> {\n\n    if (this.cacheOntology.ontologies.length === 0) {\n        // nothing in cache yet, get metadata from Knora\n        return this.getOntologiesMetadataFromKnora().pipe(\n            map(\n                metadata => {\n                    this.convertAndWriteOntologiesMetadataToCache(metadata['@graph'].filter((onto) => {\n                        // ignore excluded ontologies\n                        return this.excludedOntologies.indexOf(onto['@id']) === -1;\n                    }));\n                    return this.getAllOntologiesMetadataFromCache();\n                }\n            )\n        );\n    } else {\n        // return metadata from cache\n        return of(this.getAllOntologiesMetadataFromCache());\n    }\n\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string[]} ontologyIris Iris of the ontologies to be requested.",
        "name": "ontologyIris",
        "description": "<p>Iris of the ontologies to be requested.</p>",
        "types": [
          "Array.<string>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>string</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "Observable<any[]>",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Observable&lt;any[]&gt;</p>"
      }
    ],
    "description": {
      "full": "<p>Requests the requested ontologies from Knora, adding them to the cache.</p>",
      "summary": "<p>Requests the requested ontologies from Knora, adding them to the cache.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 793,
    "codeStart": 799,
    "code": "private getAndCacheOntologies(ontologyIris: string[]): Observable<any[]> {\n\n    // array to be populated with Observables\n    const observables = [];\n\n    // do a request for each ontology\n    ontologyIris.forEach(ontologyIri => {\n        // push an Observable onto `observables`\n        observables.push(this.getAllEntityDefinitionsForOntologyFromKnora(ontologyIri).pipe(\n            map(\n                (ontology: object) => {\n                    // write response to cache\n                    this.convertAndWriteAllEntityDefinitionsForOntologyToCache(ontology);\n                }\n            )\n        ));\n    });\n\n    // forkJoin returns an Observable of an array of results\n    // returned by each Observable contained in `observables`\n    // a subscription to the Observable returned by forkJoin is executed\n    // once all Observables have been completed\n    return forkJoin(observables);\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string[]} ontologyIris Iris of the ontologies to be queried.",
        "name": "ontologyIris",
        "description": "<p>Iris of the ontologies to be queried.</p>",
        "types": [
          "Array.<string>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>string</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "Observable<OntologyInformation> - all ontology metadata from the cache",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Observable<OntologyInformation> - all ontology metadata from the cache</p>"
      }
    ],
    "description": {
      "full": "<p>Returns the entity definitions for the requested ontologies.</p>",
      "summary": "<p>Returns the entity definitions for the requested ontologies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 825,
    "codeStart": 831,
    "code": "public getEntityDefinitionsForOntologies(ontologyIris: string[]): Observable<OntologyInformation> {\n\n    const ontologyIrisToQuery = ontologyIris.filter(\n        ontologyIri => {\n            // return the ontology Iris that are not cached yet\n            return this.cacheOntology.resourceClassIrisForOntology[ontologyIri] === undefined;\n        });\n\n    // get ontologies that are mot cached yet\n    if (ontologyIrisToQuery.length > 0) {\n\n        return this.getAndCacheOntologies(ontologyIrisToQuery).pipe(\n            mergeMap(\n                results => {\n                    // executed once all ontologies have been cached\n                    return this.getOntologyInformationFromCache(ontologyIris);\n                }\n            )\n        );\n    } else {\n\n        return this.getOntologyInformationFromCache(ontologyIris);\n    }\n\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string[]} resourceClassIris the given resource class Iris",
        "name": "resourceClassIris",
        "description": "<p>the given resource class Iris</p>",
        "types": [
          "Array.<string>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>string</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "Observable<OntologyInformation> - the requested resource classes (including properties).",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Observable<OntologyInformation> - the requested resource classes (including properties).</p>"
      }
    ],
    "description": {
      "full": "<p>Returns the definitions for the given resource class Iris.<br />\nIf the definitions are not already in the cache, the will be retrieved from Knora and cached.</p>\n<p>Properties contained in the cardinalities will be returned too.</p>",
      "summary": "<p>Returns the definitions for the given resource class Iris.<br />\nIf the definitions are not already in the cache, the will be retrieved from Knora and cached.</p>",
      "body": "<p>Properties contained in the cardinalities will be returned too.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 857,
    "codeStart": 866,
    "code": "public getResourceClassDefinitions(resourceClassIris: string[]): Observable<OntologyInformation> {\n\n    const resClassIrisToQueryFor: string[] = resourceClassIris.filter(\n        resClassIri => {\n\n            // return the resource class Iris that are not cached yet\n            return this.cacheOntology.resourceClasses[resClassIri] === undefined;\n\n        });\n\n    if (resClassIrisToQueryFor.length > 0) {\n\n        // get a set of ontology Iris that have to be queried to obtain the missing resource classes\n        const ontologyIris: string[] = resClassIrisToQueryFor.map(\n            resClassIri => {\n                return Utils.getOntologyIriFromEntityIri(resClassIri);\n            }\n        ).filter(Utils.filterOutDuplicates);\n\n        // obtain missing resource class information\n        return this.getAndCacheOntologies(ontologyIris).pipe(\n            mergeMap(\n                results => {\n\n                    return this.getResourceClassDefinitionsFromCache(resourceClassIris);\n                }\n            )\n        );\n    } else {\n\n        return this.getResourceClassDefinitionsFromCache(resourceClassIris);\n\n    }\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string[]} propertyIris the Iris of the properties to be returned .",
        "name": "propertyIris",
        "description": "<p>the Iris of the properties to be returned .</p>",
        "types": [
          "Array.<string>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>string</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "Observable<OntologyInformation> - the requested property definitions.",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Observable<OntologyInformation> - the requested property definitions.</p>"
      }
    ],
    "description": {
      "full": "<p>Get definitions for the given property Iris.<br />\nIf the definitions are not already in the cache, the will be retrieved from Knora and cached.</p>",
      "summary": "<p>Get definitions for the given property Iris.<br />\nIf the definitions are not already in the cache, the will be retrieved from Knora and cached.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 901,
    "codeStart": 908,
    "code": "public getPropertyDefinitions(propertyIris: string[]): Observable<OntologyInformation> {\n\n    const propertiesToQuery: string[] = propertyIris.filter(\n        propIri => {\n\n            // ignore non Knora props: if propIri is contained in excludedProperties, skip this propIri\n            if (this.excludedProperties.indexOf(propIri) > -1) {\n                return false;\n            }\n\n            // return the property Iris that are not cached yet\n            return this.cacheOntology.properties[propIri] === undefined;\n        }\n    );\n\n    if (propertiesToQuery.length > 0) {\n\n        // get a set of ontology Iris that have to be queried to obtain the missing properties\n        const ontologyIris: string[] = propertiesToQuery.map(\n            propIri => {\n                return Utils.getOntologyIriFromEntityIri(propIri);\n            }\n        ).filter(Utils.filterOutDuplicates);\n\n        // obtain missing resource class information\n        return this.getAndCacheOntologies(ontologyIris).pipe(\n            map(\n                results => {\n                    if (results) {\n                        return this.getPropertyDefinitionsFromCache(propertyIris);\n                    } else {\n                        throw new Error('Problem with: return this.getPropertyDefinitionsFromCache(propertyIris);');\n                    }\n                }\n            )\n        );\n    } else {\n        return of(this.getPropertyDefinitionsFromCache(propertyIris));\n    }\n}\n}",
    "ctx": false
  }
]