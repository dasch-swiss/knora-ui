[
  {
    "tags": [
      {
        "type": "deprecated",
        "string": "since v9.5.0 \nRequest information about the future of this service on the repository `@knora/api` (github:dasch-swiss/knora-api-js-lib).\n\nRequests representation of resources from Knora.",
        "html": "<p>since v9.5.0<br />\nRequest information about the future of this service on the repository <code>@knora/api</code> (github:dasch-swiss/knora-api-js-lib).</p>\n<p>Requests representation of resources from Knora.</p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 14,
    "codeStart": 21,
    "code": "@Injectable({\n    providedIn: 'root'\n})\nexport class ResourceService extends ApiService {\n\n    constructor(public http: HttpClient,\n        @Inject(KuiCoreConfigToken) public config,\n        private _incomingService: IncomingService,\n        private _ontologyCacheService: OntologyCacheService) {\n        super(http, config);\n    }",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "deprecated",
        "string": "since v9.5.0 \nGiven the Iri, requests the representation of a resource.",
        "html": "<p>since v9.5.0<br />\nGiven the Iri, requests the representation of a resource.</p>"
      },
      {
        "type": "param",
        "string": "{string} iri Iri of the resource (not yet URL encoded).",
        "name": "iri",
        "description": "<p>Iri of the resource (not yet URL encoded).</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "Observable<ApiServiceResult>",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Observable<ApiServiceResult></p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 33,
    "codeStart": 41,
    "code": "// this should return a resource object with incoming links, annotations, file representations\n// it includes a property: FileRepresentation to display with the parameters for the media type viewer\ngetResource(iri: string): Observable<ResourcesSequence | ApiServiceError> {\n\n    const res: Observable<ApiServiceResult | ApiServiceError> = this.httpGet('/v2/resources/' + encodeURIComponent(iri));\n\n    return res.pipe(\n        mergeMap(\n            // this would return an Observable of a PromiseObservable -> combine them into one Observable\n            this.processJSONLD\n        ),\n        mergeMap(\n            // return Observable of ReadResourcesSequence\n            (resourceResponse: object) => {\n                // convert JSON-LD into a ReadResourceSequence\n                const resSeq: ResourcesSequence = ConvertJSONLD.createResourcesSequenceFromJsonLD(resourceResponse);\n\n                // collect resource class Iris\n                const resourceClassIris: string[] = ConvertJSONLD.getResourceClassesFromJsonLD(resourceResponse);\n\n                const res0 = resSeq.resources[0];\n\n                // set file representation to display\n\n                const propKeys: string[] = Object.keys(res0.properties);\n                switch (true) {\n                    case propKeys.includes(KnoraConstants.hasStillImageFileValue):\n                        // res.fileRepresentationsToDisplay[0] = res.properties[KnoraConstants.hasStillImageFileValue];\n\n                        const imgRepresentations: StillImageRepresentation[] = [];\n\n                        const fileValues: ReadStillImageFileValue[] = res0.properties[KnoraConstants.hasStillImageFileValue] as ReadStillImageFileValue[];\n                        const imagesToDisplay: ReadStillImageFileValue[] = fileValues.filter((image) => {\n                            return !image.isPreview;\n                        });\n\n                        for (const img of imagesToDisplay) {\n\n                            const regions: Region[] = [];\n                            for (const incomingRegion of res0.incomingAnnotations) {\n\n                                // TODO: change return type in Region from ReadResource into Resource\n                                // const region = new Region(incomingRegion);\n\n                                // regions.push(region);\n\n                            }\n\n                            const stillImage = new StillImageRepresentation(img, regions);\n                            imgRepresentations.push(stillImage);\n\n                        }\n\n                        res0.fileRepresentationsToDisplay.stillImage = imgRepresentations;\n\n                        break;\n                    case propKeys.includes(KnoraConstants.hasMovingImageFileValue):\n                        // res0.fileRepresentationsToDisplay = res0.properties[KnoraConstants.hasMovingImageFileValue];\n                        break;\n                    case propKeys.includes(KnoraConstants.hasAudioFileValue):\n                        // res0.fileRepresentationsToDisplay = res0.properties[KnoraConstants.hasAudioFileValue];\n                        break;\n                    case propKeys.includes(KnoraConstants.hasDocumentFileValue):\n                        // res0.fileRepresentationsToDisplay = res0.properties[KnoraConstants.hasDocumentFileValue];\n                        break;\n                    case propKeys.includes(KnoraConstants.hasDDDFileValue):\n                        // res0.fileRepresentationsToDisplay = res0.properties[KnoraConstants.hasDDDFileValue];\n                        break;\n\n                    // TODO: TextFileValue\n\n                    default:\n                        // look for incoming fileRepresentation to display\n                        // get incoming stillImage files\n                        this._incomingService.getStillImageRepresentationsForCompoundResource(res0.id, 0).subscribe(\n                            (incomingFiles: ReadResourcesSequence) => {\n\n                                // console.log('incomingFiles', incomingFiles);\n\n                                if (incomingFiles.resources.length > 0) {\n                                    // update ontology information\n                                    resSeq.ontologyInformation.updateOntologyInformation(incomingFiles.ontologyInformation);\n\n\n                                    // set current offset\n                                    // this.incomingStillImageRepresentationCurrentOffset = offset;\n\n                                    // TODO: implement prepending of StillImageRepresentations when moving to the left (getting previous pages)\n                                    // TODO: append existing images to response and then assign response to `this.resource.incomingStillImageRepresentations`\n                                    // TODO: maybe we have to support non consecutive arrays (sparse arrays)\n\n                                    // append incomingImageRepresentations.resources to this.resource.incomingStillImageRepresentations\n\n                                    Array.prototype.push.apply(res0.incomingFileRepresentations, incomingFiles.resources);\n                                    // Array.prototype.push.apply(resSeq.resources[0].incomingFileRepresentations, incomingImageRepresentations.resources);\n\n                                    const incomingImgRepresentations: StillImageRepresentation[] = [];\n\n                                    for (const inRes of incomingFiles.resources) {\n\n\n\n                                        const incomingFileValues: ReadStillImageFileValue[] = inRes.properties[KnoraConstants.hasStillImageFileValue] as ReadStillImageFileValue[];\n                                        const incomingImagesToDisplay: ReadStillImageFileValue[] = incomingFileValues.filter((image) => {\n                                            return !image.isPreview;\n                                        });\n\n                                        for (const img of incomingImagesToDisplay) {\n\n                                            const regions: Region[] = [];",
    "ctx": false
  },
  {
    "tags": [],
    "description": {
      "full": "<p>for (const incomingRegion of inRes.incomingAnnotations) {</p>\n<pre><code>                                                // TODO: change return type in Region from ReadResource into Resource\n                                                // const region = new Region(incomingRegion);\n\n                                                // regions.push(incomingRegion);\n\n                                            }</code></pre>",
      "summary": "<p>for (const incomingRegion of inRes.incomingAnnotations) {</p>",
      "body": "<pre><code>                                                // TODO: change return type in Region from ReadResource into Resource\n                                                // const region = new Region(incomingRegion);\n\n                                                // regions.push(incomingRegion);\n\n                                            }</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 151,
    "codeStart": 162,
    "code": "const stillImage = new StillImageRepresentation(img, regions);\nincomingImgRepresentations.push(stillImage);\n\n                                            }\n\n                                            res0.fileRepresentationsToDisplay.stillImage = incomingImgRepresentations;\n\n                                        }\n\n\n                                        // prepare attached image files to be displayed\n                                        // BeolResource.collectImagesAndRegionsForResource(this.resource);\n                                    }\n                                },\n                                (error: any) => {\n                                    console.error(error);\n                                }\n                            );\n                    }\n\n\n                    // get incoming links\n                    this._incomingService.getIncomingLinks(resSeq.resources[0].id, 0).subscribe(\n                        (incomingRes: ResourcesSequence) => {\n                            // update ontology information\n                            resSeq.ontologyInformation.updateOntologyInformation(incomingRes.ontologyInformation);\n\n                            // Append elements incomingResources to this.sequence.incomingLinks\n                            Array.prototype.push.apply(resSeq.resources[0].incomingLinks, incomingRes.resources);\n                        }\n                    );\n\n                    // get incoming annotations\n\n\n                    // request information about resource classes\n                    return this._ontologyCacheService.getResourceClassDefinitions(resourceClassIris).pipe(\n                        map(\n                            (ontoInfo: OntologyInformation) => {\n                                // add ontology information to ReadResourceSequence\n                                resSeq.ontologyInformation.updateOntologyInformation(ontoInfo);\n\n                                // console.log('resSeq -- resourceServie', resSeq);\n\n                                return resSeq;\n                            }\n                        )\n                    );\n                }\n\n            )\n        );\n\n    }",
    "ctx": {
      "type": "declaration",
      "name": "stillImage",
      "value": "new StillImageRepresentation(img, regions)",
      "string": "stillImage"
    }
  },
  {
    "tags": [
      {
        "type": "deprecated",
        "string": "since v9.5.0",
        "html": "<p>since v9.5.0</p>"
      },
      {
        "type": "param",
        "string": "iri",
        "name": "iri",
        "description": "",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "html": "<p>iri</p>"
      },
      {
        "type": "returns",
        "string": "Observable<ResourcesSequence | ApiServiceError>",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Observable&lt;ResourcesSequence | ApiServiceError&gt;</p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 217,
    "codeStart": 223,
    "code": "private getResourcesSequence(iri: string): Observable<ResourcesSequence | ApiServiceError> {\n    const res: Observable<ApiServiceResult | ApiServiceError> = this.httpGet('/v2/resources/' + encodeURIComponent(iri));\n\n    return res.pipe(\n        mergeMap(\n            // this would return an Observable of a PromiseObservable -> combine them into one Observable\n            this.processJSONLD\n        ),\n        mergeMap(\n            // return Observable of ReadResourcesSequence\n            (resourceResponse: object) => {\n                // convert JSON-LD into a ReadResourceSequence\n                const resSeq: ResourcesSequence = ConvertJSONLD.createResourcesSequenceFromJsonLD(resourceResponse);\n\n                // collect resource class Iris\n                const resourceClassIris: string[] = ConvertJSONLD.getResourceClassesFromJsonLD(resourceResponse);\n\n\n\n                // request information about resource classes\n                return this._ontologyCacheService.getResourceClassDefinitions(resourceClassIris).pipe(\n                    map(\n                        (ontoInfo: OntologyInformation) => {\n                            // add ontology information to ReadResourceSequence\n                            resSeq.ontologyInformation.updateOntologyInformation(ontoInfo);\n                            return resSeq;\n                        }\n                    )\n                );\n            }\n        )\n    );\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "deprecated",
        "string": "since v9.5.0",
        "html": "<p>since v9.5.0</p>"
      },
      {
        "type": "param",
        "string": "sequence",
        "name": "sequence",
        "description": "",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "html": "<p>sequence</p>"
      },
      {
        "type": "returns",
        "string": "void",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>void</p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 257,
    "codeStart": 263,
    "code": "requestIncomingResources(sequence: ResourcesSequence): void {\n\n    // make sure that this.sequence has been initialized correctly\n    if (sequence === undefined) {\n        return;\n    }\n\n    // request incoming sequences in case of movingImage and audio\n\n    // request incoming regions in case of stillImage and dddImage\n    if (sequence.resources[0].properties[KnoraConstants.hasStillImageFileValue]) {\n        // TODO: check if resources is a StillImageRepresentation using the ontology responder (support for subclass relations required)\n        // the resource is a StillImageRepresentation, check if there are regions pointing to it\n\n        // this.getIncomingRegions(0);\n\n    } else {\n        // this resource is not a StillImageRepresentation\n        // check if there are StillImageRepresentations pointing to this resource\n\n        // this gets the first page of incoming StillImageRepresentations\n        // more pages may be requested by [[this.viewer]].\n        // TODO: for now, we begin with offset 0. This may have to be changed later (beginning somewhere in a collection)\n        // this.getIncomingStillImageRepresentations(0);\n    }\n\n    // check for incoming links for the current resource\n    // this.getIncomingLinks(0);\n\n\n}",
    "ctx": {
      "type": "method",
      "name": "requestIncomingResources",
      "string": "requestIncomingResources()"
    }
  },
  {
    "tags": [
      {
        "type": "deprecated",
        "string": "Use **getResourcesSequence** instead \nGiven the Iri, requests the representation of a resource as a `ReadResourceSequence`.",
        "html": "<p>Use <strong>getResourcesSequence</strong> instead<br />\nGiven the Iri, requests the representation of a resource as a <code>ReadResourceSequence</code>.</p>"
      },
      {
        "type": "param",
        "string": "{string} iri Iri of the resource (not yet URL encoded).",
        "name": "iri",
        "description": "<p>Iri of the resource (not yet URL encoded).</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Observable<ReadResourcesSequence>}",
        "types": [
          "Observable.<ReadResourcesSequence>"
        ],
        "typesDescription": "<a href=\"Observable.html\">Observable</a>.&lt;<a href=\"ReadResourcesSequence.html\">ReadResourcesSequence</a>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "",
        "html": "<p>{Observable<ReadResourcesSequence>}</p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 295,
    "codeStart": 303,
    "code": "getReadResource(iri: string): Observable<ReadResourcesSequence | ApiServiceError> {\n    const res: Observable<ApiServiceResult | ApiServiceError> = this.httpGet('/v2/resources/' + encodeURIComponent(iri));\n\n    // TODO: handle case of an ApiServiceError\n\n    return res.pipe(\n        mergeMap(\n            // this would return an Observable of a PromiseObservable -> combine them into one Observable\n            this.processJSONLD\n        ),\n        mergeMap(\n            // return Observable of ReadResourcesSequence\n            (resourceResponse: object) => {\n                // convert JSON-LD into a ReadResourceSequence\n                const resSeq: ReadResourcesSequence = ConvertJSONLD.createReadResourcesSequenceFromJsonLD(resourceResponse);\n\n                // collect resource class Iris\n                const resourceClassIris: string[] = ConvertJSONLD.getResourceClassesFromJsonLD(resourceResponse);\n\n                // request information about resource classes\n                return this._ontologyCacheService.getResourceClassDefinitions(resourceClassIris).pipe(\n                    map(\n                        (ontoInfo: OntologyInformation) => {\n                            // add ontology information to ReadResourceSequence\n                            resSeq.ontologyInformation.updateOntologyInformation(ontoInfo);\n                            return resSeq;\n                        }\n                    )\n                );\n            }\n        )\n    );\n}",
    "ctx": {
      "type": "method",
      "name": "getReadResource",
      "string": "getReadResource()"
    }
  },
  {
    "tags": [
      {
        "type": "deprecated",
        "string": "since v9.5.0 \nGet a resource by IRI and return the json-ld result;\nit will be used for the request body object in delete and erase resource",
        "html": "<p>since v9.5.0<br />\nGet a resource by IRI and return the json-ld result;<br />\nit will be used for the request body object in delete and erase resource</p>"
      },
      {
        "type": "param",
        "string": "{string} iri",
        "name": "iri",
        "description": "",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{string} iri</p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 337,
    "codeStart": 345,
    "code": "getResourceAsJsonLd(iri: string): Observable<any> {\n\n    return this.httpGet('/v2/resources/' + encodeURIComponent(iri)).pipe(\n        map((result: ApiServiceResult) => result.body),\n        catchError(this.handleJsonError)\n    );\n\n}",
    "ctx": {
      "type": "method",
      "name": "getResourceAsJsonLd",
      "string": "getResourceAsJsonLd()"
    }
  },
  {
    "tags": [
      {
        "type": "deprecated",
        "string": "since v9.5.0 \nDelete resource\n\nKnora does not normally delete resources; instead, it marks them as deleted, which means that they do not appear in normal query results.",
        "html": "<p>since v9.5.0<br />\nDelete resource</p>\n<p>Knora does not normally delete resources; instead, it marks them as deleted, which means that they do not appear in normal query results.</p>"
      },
      {
        "type": "param",
        "string": "{string} iri Iri of the resource",
        "name": "iri",
        "description": "<p>Iri of the resource</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} [comment] Specifies a comment to be attached to the resource, explaining why it has been marked as deleted. Will be ignored if param erase is true.",
        "name": "[comment]",
        "description": "<p>Specifies a comment to be attached to the resource, explaining why it has been marked as deleted. Will be ignored if param erase is true.</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{boolean} [erase] Delete completely from triplestore. Default false.",
        "name": "[erase]",
        "description": "<p>Delete completely from triplestore. Default false.</p>",
        "types": [
          "boolean"
        ],
        "typesDescription": "<code>boolean</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 354,
    "codeStart": 365,
    "code": "deleteResource(iri: string, comment: string = '', erase: boolean = false) {\n    const path: string = (erase ? '/v2/resources/erase' : '/v2/resources/delete');\n\n    // get resource first to have the knora-api:lastModificationDate\n    this.getResourceAsJsonLd(iri).subscribe(\n        (result: any) => {\n            const requestBody: any = {\n                '@id': iri,\n                '@type': result['@type'],\n                '@context': result['@context']\n            };\n\n            // the resource exists; get the info needed in the request body\n            if (result['knora-api:lastModificationDate']) {\n                requestBody['knora-api:lastModificationDate'] = result['knora-api:lastModificationDate'];\n            }\n\n            if (comment.length > 0 && !erase) {\n                requestBody['knora-api:deleteComment'] = comment;\n            }\n\n            // send the request body to the delete route\n            this.httpPost(path, requestBody).subscribe(\n                (resp: any) => {\n                    // TODO: return something here\n                    // console.log(resp);\n                },\n                (err: any) => {\n                    console.error(err);\n                }\n            );\n\n        },\n        (error: ApiServiceError) => {\n            console.error('failed to get resource', error);\n        }\n    );\n\n}",
    "ctx": {
      "type": "method",
      "name": "deleteResource",
      "string": "deleteResource()"
    }
  },
  {
    "tags": [
      {
        "type": "deprecated",
        "string": "since v9.5.0 \nErase resource (from triplestore)",
        "html": "<p>since v9.5.0<br />\nErase resource (from triplestore)</p>"
      },
      {
        "type": "param",
        "string": "{string} iri Iri of the resource",
        "name": "iri",
        "description": "<p>Iri of the resource</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} type Resource class",
        "name": "type",
        "description": "<p>Resource class</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 405,
    "codeStart": 414,
    "code": "eraseResource(iri: string) {\n    // get resource first to have the knora-api:lastModificationDate\n    this.getResourceAsJsonLd(iri).subscribe(\n        (result: any) => {\n            const requestBody: any = {\n                '@id': iri,\n                '@type': result['@type'],\n                '@context': result['@context']\n            };\n\n            // the resource exists; get the info needed in the request body\n            if (result['knora-api:lastModificationDate']) {\n                requestBody['knora-api:lastModificationDate'] = result['knora-api:lastModificationDate'];\n            }\n\n            // send the request body to the delete route\n            this.httpPost('/v2/resources/erase', requestBody).subscribe(\n                (resp: any) => {\n                    // TODO: return something here\n                    // console.log(resp);\n                },\n                (err: any) => {\n                    console.error(err);\n                }\n            );\n\n        },\n        (error: ApiServiceError) => {\n            console.error('failed to get resource', error);\n        }\n    );\n\n}\n\n}",
    "ctx": {
      "type": "method",
      "name": "eraseResource",
      "string": "eraseResource()"
    }
  }
]