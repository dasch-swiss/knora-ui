[
  {
    "tags": [],
    "description": {
      "full": "<p>Requests representation of resources from Knora.</p>",
      "summary": "<p>Requests representation of resources from Knora.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 12,
    "codeStart": 15,
    "code": "@Injectable({\n    providedIn: 'root'\n})\nexport class ResourceService extends ApiService {\n\n    constructor (public http: HttpClient,\n        @Inject(KuiCoreConfigToken) public config,\n        private _incomingService: IncomingService,\n        private _ontologyCacheService: OntologyCacheService) {\n        super(http, config);\n    }",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string} iri Iri of the resource (not yet URL encoded).",
        "name": "iri",
        "description": "<p>Iri of the resource (not yet URL encoded).</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "Observable<ApiServiceResult>",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "<p>Observable<ApiServiceResult></p>"
      }
    ],
    "description": {
      "full": "<p>Given the Iri, requests the representation of a resource.</p>",
      "summary": "<p>Given the Iri, requests the representation of a resource.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 27,
    "codeStart": 33,
    "code": "// this should return a resource object with incoming links, annotations, file representations\n// it includes a property: FileRepresentation to display with the parameters for the media type viewer\ngetResource(iri: string): Observable<ResourcesSequence | ApiServiceError> {\n\n    const res: Observable<ApiServiceResult | ApiServiceError> = this.httpGet('/v2/resources/' + encodeURIComponent(iri));\n\n    return res.pipe(\n        mergeMap(\n            // this would return an Observable of a PromiseObservable -> combine them into one Observable\n            this.processJSONLD\n        ),\n        mergeMap(\n            // return Observable of ReadResourcesSequence\n            (resourceResponse: object) => {\n                // convert JSON-LD into a ReadResourceSequence\n                const resSeq: ResourcesSequence = ConvertJSONLD.createResourcesSequenceFromJsonLD(resourceResponse);\n\n                // collect resource class Iris\n                const resourceClassIris: string[] = ConvertJSONLD.getResourceClassesFromJsonLD(resourceResponse);\n\n                const res0 = resSeq.resources[0];\n\n                // set file representation to display\n\n                const propKeys: string[] = Object.keys(res0.properties);\n                switch (true) {\n                    case propKeys.includes(KnoraConstants.hasStillImageFileValue):\n                        // res.fileRepresentationsToDisplay[0] = res.properties[KnoraConstants.hasStillImageFileValue];\n\n                        const imgRepresentations: StillImageRepresentation[] = [];\n\n                        const fileValues: ReadStillImageFileValue[] = res0.properties[KnoraConstants.hasStillImageFileValue] as ReadStillImageFileValue[];\n                        const imagesToDisplay: ReadStillImageFileValue[] = fileValues.filter((image) => {\n                            return !image.isPreview;\n                        });\n\n                        for (const img of imagesToDisplay) {\n\n                            const regions: Region[] = [];\n                            for (const incomingRegion of res0.incomingAnnotations) {\n\n                                // TODO: change return type in Region from ReadResource into Resource\n                                // const region = new Region(incomingRegion);\n\n                                // regions.push(region);\n\n                            }\n\n                            const stillImage = new StillImageRepresentation(img, regions);\n                            imgRepresentations.push(stillImage);\n\n                        }\n\n                        res0.fileRepresentationsToDisplay.stillImage = imgRepresentations;\n\n                        break;\n                    case propKeys.includes(KnoraConstants.hasMovingImageFileValue):\n                        //                            res0.fileRepresentationsToDisplay = res0.properties[KnoraConstants.hasMovingImageFileValue];\n                        break;\n                    case propKeys.includes(KnoraConstants.hasAudioFileValue):\n                        //                            res0.fileRepresentationsToDisplay = res0.properties[KnoraConstants.hasAudioFileValue];\n                        break;\n                    case propKeys.includes(KnoraConstants.hasDocumentFileValue):\n                        //                            res0.fileRepresentationsToDisplay = res0.properties[KnoraConstants.hasDocumentFileValue];\n                        break;\n                    case propKeys.includes(KnoraConstants.hasDDDFileValue):\n                        //                            res0.fileRepresentationsToDisplay = res0.properties[KnoraConstants.hasDDDFileValue];\n                        break;\n\n                    // TODO: TextFileValue\n\n                    default:\n                        // look for incoming fileRepresentation to display\n                        // get incoming stillImage files\n                        this._incomingService.getStillImageRepresentationsForCompoundResource(res0.id, 0).subscribe(\n                            (incomingFiles: ReadResourcesSequence) => {\n\n                                // console.log('incomingFiles', incomingFiles);\n\n                                if (incomingFiles.resources.length > 0) {\n                                    // update ontology information\n                                    resSeq.ontologyInformation.updateOntologyInformation(incomingFiles.ontologyInformation);\n\n\n                                    // set current offset\n                                    // this.incomingStillImageRepresentationCurrentOffset = offset;\n\n                                    // TODO: implement prepending of StillImageRepresentations when moving to the left (getting previous pages)\n                                    // TODO: append existing images to response and then assign response to `this.resource.incomingStillImageRepresentations`\n                                    // TODO: maybe we have to support non consecutive arrays (sparse arrays)\n\n                                    // append incomingImageRepresentations.resources to this.resource.incomingStillImageRepresentations\n\n                                    Array.prototype.push.apply(res0.incomingFileRepresentations, incomingFiles.resources);\n                                    // Array.prototype.push.apply(resSeq.resources[0].incomingFileRepresentations, incomingImageRepresentations.resources);\n\n                                    const incomingImgRepresentations: StillImageRepresentation[] = [];\n\n                                    for (const inRes of incomingFiles.resources) {\n\n\n\n                                        const incomingFileValues: ReadStillImageFileValue[] = inRes.properties[KnoraConstants.hasStillImageFileValue] as ReadStillImageFileValue[];\n                                        const incomingImagesToDisplay: ReadStillImageFileValue[] = incomingFileValues.filter((image) => {\n                                            return !image.isPreview;\n                                        });\n\n                                        for (const img of incomingImagesToDisplay) {\n\n                                            const regions: Region[] = [];",
    "ctx": false
  },
  {
    "tags": [],
    "description": {
      "full": "<p>for (const incomingRegion of inRes.incomingAnnotations) {</p>\n<pre><code>                                                // TODO: change return type in Region from ReadResource into Resource\n                                                // const region = new Region(incomingRegion);\n\n                                                // regions.push(incomingRegion);\n\n                                            }</code></pre>",
      "summary": "<p>for (const incomingRegion of inRes.incomingAnnotations) {</p>",
      "body": "<pre><code>                                                // TODO: change return type in Region from ReadResource into Resource\n                                                // const region = new Region(incomingRegion);\n\n                                                // regions.push(incomingRegion);\n\n                                            }</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 143,
    "codeStart": 154,
    "code": "const stillImage = new StillImageRepresentation(img, regions);\nincomingImgRepresentations.push(stillImage);\n\n                                            }\n\n                                            res0.fileRepresentationsToDisplay.stillImage = incomingImgRepresentations;\n\n                                        }\n\n\n                                        // prepare attached image files to be displayed\n                                        // BeolResource.collectImagesAndRegionsForResource(this.resource);\n                                    }\n                                },\n                                (error: any) => {\n                                    console.error(error);\n                                }\n                            );\n\n                        // do the same for all other incoming file representations\n                        // TODO: get incoming movingImage files\n\n                        // TODO: get incoming audio files\n\n                        // TODO: get incoming document files\n\n                        // TODO: get incoming text files\n\n                        // TODO: get ddd images files\n                    }\n\n\n                    // resource.properties[KnoraConstants.hasStillImageFileValue]\n\n\n                    // get incoming links\n                    this._incomingService.getIncomingLinks(resSeq.resources[0].id, 0).subscribe(\n                        (incomingRes: ResourcesSequence) => {\n                            // update ontology information\n                            resSeq.ontologyInformation.updateOntologyInformation(incomingRes.ontologyInformation);\n\n                            // Append elements incomingResources to this.sequence.incomingLinks\n                            Array.prototype.push.apply(resSeq.resources[0].incomingLinks, incomingRes.resources);\n                        }\n                    );\n\n                    // get incoming annotations\n\n\n                    // request information about resource classes\n                    return this._ontologyCacheService.getResourceClassDefinitions(resourceClassIris).pipe(\n                        map(\n                            (ontoInfo: OntologyInformation) => {\n                                // add ontology information to ReadResourceSequence\n                                resSeq.ontologyInformation.updateOntologyInformation(ontoInfo);\n\n                                // console.log('resSeq -- resourceServie', resSeq);\n\n                                return resSeq;\n                            }\n                        )\n                    );\n                }\n\n            )\n        );\n\n        // let resSeq: Observable<ResourcesSequence>;",
    "ctx": {
      "type": "declaration",
      "name": "stillImage",
      "value": "new StillImageRepresentation(img, regions)",
      "string": "stillImage"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>this.getResourcesSequence(iri).subscribe(<br />\n(sequence: ResourcesSequence) =&gt; {</p>\n<pre><code>            // resSeq = sequence;\n\n            /* pipe(\n                map((result: ApiServiceResult) =&gt; result.getBody(GroupsResponse).groups),\n                catchError(this.handleJsonError)\n            );\n\n            resSeq.pipe(\n                map((seq: ResourcesSequence) =&gt; sequence),\n                catchError(this.handleJsonError)\n            ); *\n\n            // get incoming links\n            this._incomingService.getIncomingLinks(sequence.resources[0].id, 0).subscribe(\n                (incomingResources: ResourcesSequence) =&gt; {\n                    // update ontology information\n                    sequence.ontologyInformation.updateOntologyInformation(incomingResources.ontologyInformation);\n\n                    // Append elements incomingResources to this.sequence.incomingLinks\n                    Array.prototype.push.apply(sequence.resources[0].incomingLinks, incomingResources.resources);\n\n                    // if callback is given, execute function with the amount of incoming resources as the parameter\n                    /* TODO: what is callback? Find a solution\n                    if (callback !== undefined) {\n                        callback(incomingResources.resources.length);\n                    }\n\n\n                },\n                (error: any) =&gt; {\n                    console.error(error);\n                }\n            );\n\n            // get incoming annotations\n\n            // get incoming filerepresentations\n\n\n\n        },\n        (error: ApiServiceError) =&gt; {\n            console.error(error);\n            return error;\n        }\n    );\n\n\n    return resSeq;</code></pre>",
      "summary": "<p>this.getResourcesSequence(iri).subscribe(<br />\n(sequence: ResourcesSequence) =&gt; {</p>",
      "body": "<pre><code>            // resSeq = sequence;\n\n            /* pipe(\n                map((result: ApiServiceResult) =&gt; result.getBody(GroupsResponse).groups),\n                catchError(this.handleJsonError)\n            );\n\n            resSeq.pipe(\n                map((seq: ResourcesSequence) =&gt; sequence),\n                catchError(this.handleJsonError)\n            ); *\n\n            // get incoming links\n            this._incomingService.getIncomingLinks(sequence.resources[0].id, 0).subscribe(\n                (incomingResources: ResourcesSequence) =&gt; {\n                    // update ontology information\n                    sequence.ontologyInformation.updateOntologyInformation(incomingResources.ontologyInformation);\n\n                    // Append elements incomingResources to this.sequence.incomingLinks\n                    Array.prototype.push.apply(sequence.resources[0].incomingLinks, incomingResources.resources);\n\n                    // if callback is given, execute function with the amount of incoming resources as the parameter\n                    /* TODO: what is callback? Find a solution\n                    if (callback !== undefined) {\n                        callback(incomingResources.resources.length);\n                    }\n\n\n                },\n                (error: any) =&gt; {\n                    console.error(error);\n                }\n            );\n\n            // get incoming annotations\n\n            // get incoming filerepresentations\n\n\n\n        },\n        (error: ApiServiceError) =&gt; {\n            console.error(error);\n            return error;\n        }\n    );\n\n\n    return resSeq;</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 223,
    "codeStart": 279,
    "code": "}\n\nprivate getResourcesSequence(iri: string): Observable<ResourcesSequence | ApiServiceError> {\n    const res: Observable<ApiServiceResult | ApiServiceError> = this.httpGet('/v2/resources/' + encodeURIComponent(iri));\n\n    return res.pipe(\n        mergeMap(\n            // this would return an Observable of a PromiseObservable -> combine them into one Observable\n            this.processJSONLD\n        ),\n        mergeMap(\n            // return Observable of ReadResourcesSequence\n            (resourceResponse: object) => {\n                // convert JSON-LD into a ReadResourceSequence\n                const resSeq: ResourcesSequence = ConvertJSONLD.createResourcesSequenceFromJsonLD(resourceResponse);\n\n                // collect resource class Iris\n                const resourceClassIris: string[] = ConvertJSONLD.getResourceClassesFromJsonLD(resourceResponse);\n\n\n\n                // request information about resource classes\n                return this._ontologyCacheService.getResourceClassDefinitions(resourceClassIris).pipe(\n                    map(\n                        (ontoInfo: OntologyInformation) => {\n                            // add ontology information to ReadResourceSequence\n                            resSeq.ontologyInformation.updateOntologyInformation(ontoInfo);\n                            return resSeq;\n                        }\n                    )\n                );\n            }\n        )\n    );\n}\n\n\nrequestIncomingResources(sequence: ResourcesSequence): void {\n\n    // make sure that this.sequence has been initialized correctly\n    if (sequence === undefined) {\n        return;\n    }\n\n    // request incoming sequences in case of movingImage and audio\n\n    // request incoming regions in case of stillImage and dddImage\n    if (sequence.resources[0].properties[KnoraConstants.hasStillImageFileValue]) {\n        // TODO: check if resources is a StillImageRepresentation using the ontology responder (support for subclass relations required)\n        // the resource is a StillImageRepresentation, check if there are regions pointing to it\n\n        // this.getIncomingRegions(0);\n\n    } else {\n        // this resource is not a StillImageRepresentation\n        // check if there are StillImageRepresentations pointing to this resource\n\n        // this gets the first page of incoming StillImageRepresentations\n        // more pages may be requested by [[this.viewer]].\n        // TODO: for now, we begin with offset 0. This may have to be changed later (beginning somewhere in a collection)\n        // this.getIncomingStillImageRepresentations(0);\n    }\n\n    // check for incoming links for the current resource\n    // this.getIncomingLinks(0);\n\n\n}",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "deprecated",
        "string": "Use **getResourcesSequence** instead \nGiven the Iri, requests the representation of a resource as a `ReadResourceSequence`.",
        "html": "<p>Use <strong>getResourcesSequence</strong> instead<br />\nGiven the Iri, requests the representation of a resource as a <code>ReadResourceSequence</code>.</p>"
      },
      {
        "type": "param",
        "string": "{string} iri Iri of the resource (not yet URL encoded).",
        "name": "iri",
        "description": "<p>Iri of the resource (not yet URL encoded).</p>",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Observable<ReadResourcesSequence>}",
        "types": [
          "Observable.<ReadResourcesSequence>"
        ],
        "typesDescription": "<a href=\"Observable.html\">Observable</a>.&lt;<a href=\"ReadResourcesSequence.html\">ReadResourcesSequence</a>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "",
        "html": "<p>{Observable<ReadResourcesSequence>}</p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 348,
    "codeStart": 356,
    "code": "getReadResource(iri: string): Observable<ReadResourcesSequence | ApiServiceError> {\n    const res: Observable<ApiServiceResult | ApiServiceError> = this.httpGet('/v2/resources/' + encodeURIComponent(iri));\n\n    // TODO: handle case of an ApiServiceError\n\n    return res.pipe(\n        mergeMap(\n            // this would return an Observable of a PromiseObservable -> combine them into one Observable\n            this.processJSONLD\n        ),\n        mergeMap(\n            // return Observable of ReadResourcesSequence\n            (resourceResponse: object) => {\n                // convert JSON-LD into a ReadResourceSequence\n                const resSeq: ReadResourcesSequence = ConvertJSONLD.createReadResourcesSequenceFromJsonLD(resourceResponse);\n\n                // collect resource class Iris\n                const resourceClassIris: string[] = ConvertJSONLD.getResourceClassesFromJsonLD(resourceResponse);\n\n                // request information about resource classes\n                return this._ontologyCacheService.getResourceClassDefinitions(resourceClassIris).pipe(\n                    map(\n                        (ontoInfo: OntologyInformation) => {\n                            // add ontology information to ReadResourceSequence\n                            resSeq.ontologyInformation.updateOntologyInformation(ontoInfo);\n                            return resSeq;\n                        }\n                    )\n                );\n            }\n        )\n    );\n}\n\n// TODO: post, put, delete\n}",
    "ctx": {
      "type": "method",
      "name": "getReadResource",
      "string": "getReadResource()"
    }
  }
]